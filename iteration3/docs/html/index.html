<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: My Personal Index Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">My Personal Index Page </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Technical Users</h1>
<p>This program uses the MVC (Module - Viewer - <a class="el" href="classController.html" title="Controller that mediates Arena and GraphicsArenaViewer communication. ">Controller</a>) model to create a robot simulation. The controller handles all communication between the Module, which is the arena, and Viewer, which is the graphics. The arena contains different types of entities including: robots, lights, and foods. Lights and foods are considered stimulus in the simulation which directly affect the motion of robots. The robots so far are implemented with four sensors: two for lights sensors and two for foods sensors. All sensors get the reading directly from all stimulus in the arena and then convert the readings into wheel velocity. Each sensor connects to a particular wheel and impacts that wheel in a specific way. The combination of different connections and impacts of each sensor creates four different kinds of robots which follow the model of Braitenburg Vehicles. They are Fear, Aggression, Love, and Explore.</p>
<p>Sensors are implemented by the <a class="el" href="classObserver.html" title="Class to implement the Observer Pattern. ">Observer</a> Pattern in which the arena is the <a class="el" href="classSubject.html" title="Class to implement the Observer Pattern. ">Subject</a> whose purpose is simply to notify all sensors about the stimulus; and Sensors are the Observers who will wait for the arena to receive the updated information of the stimulus. The arena notifies the corresponding sensors based on the stimuli. For example, the arena will notify light sensors about lights only. The same happens with food sensors. The sensor, in turn, will receive the information from the arena about the stimuli, calculate the reading based on the distance to the stimuli, and generate a corresponding velocity. The sensor then updates the new velocity to the wheel that it is connecting to. The robot itself will be responsible for checking the new updated velocity to ensure it is within the acceptable range. It the new velocity happens to exceed the desired limit, the robot simply adjusts it to the set maximum velocity; or if it goes below the limit, the robot sets it to the minimum one.</p>
<p>The different models of the robot (e.g. Fear, Aggressive, Love, Exploratory) in the arena provide a good condition to apply the strategy pattern. The idea is that we would create a new general class for different models of robot called RobotModel class. This class will have all information about how many sensors the robot has, including light sensors and food sensors, how sensors are connecting to both wheels (e.g. direct connection or crossed connection), how sensors impact the velocity of both wheels (e.g. positive connection or negative connection). After creating this new class, the robot class now would have an additional member which is a pointer to the RobotModel class. This member helps to determine what kind of model the robot is simulating. For each model of the Braitenberg vehicles, we will add a new class and let it inherit from the RobotModel class. This new class connects all sensors properly to both wheels to reflect the correction motion of this model based on the Braitenberg vehicles. When we want to create a particular robot, for example a robot exhibits Fear behavior, we simply need to initialize the pointer to the RobotModel class. There are many advantages of this approach. First, a programmer can add as many new models as they want for the robot in the future. All they need to do is to create a new class for that model and make it inherit from the RobotModel class. They also need to initialize the robot_model_ pointer to the new added class in the <a class="el" href="classRobot.html" title="Class representing a robot within the arena. ">Robot</a> constructor. Another advantage is that we can change the model of any robot easily at any time in the simulation. For example, when the robot is very hungry, it should exhibit aggressive behavior to the food. We can implement this by reinitialize the robot_model_ pointer to the RobotAggressive class.</p>
<p>In order to add a new stimuli to the simulator, the programmer needs to create a new class for that stimuli and let it inherit from both the <a class="el" href="classArenaMobileEntity.html" title="A mobile entity in the Arena, capable of updating its own position and/or velocity when asked by the ...">ArenaMobileEntity</a> class (if it is a mobile stimuli) or the <a class="el" href="classArenaImmobileEntity.html" title="An immobile entity in the Arena. ">ArenaImmobileEntity</a> class (if it is an immobile stimuli) and the <a class="el" href="classSubject.html" title="Class to implement the Observer Pattern. ">Subject</a> class which is part of a <a class="el" href="classObserver.html" title="Class to implement the Observer Pattern. ">Observer</a> Pattern. The programmer also needs to implement all method from the <a class="el" href="classSubject.html" title="Class to implement the Observer Pattern. ">Subject</a> class because the <a class="el" href="classSubject.html" title="Class to implement the Observer Pattern. ">Subject</a> class only acts as an interface. This will include overriding the Notify method which allows it to send its information (e.g. position) to all of its observers (e.g. water sensors). If it is a mobile entity and it has a different motion behavior, the programmer also needs to create two new classes for the motion handler and motion behavior of the stimuli. The new stimuli class then requires to have these new motion controllers as its members.</p>
<h1><a class="anchor" id="sub_sec"></a>
Non-Technical Users</h1>
<p>The purpose of this program is to simulate the behavior of the robot with the effect of the surrounding stimulus. The program consists of the arena which contains other objects. There are three different kinds of entities such as robots, lights, and foods. Foods are immobile entities which only stay in place for the whole simulation. Robots and lights are mobile entities which can move around and collide with other entities in the arena. Lights only collide with the wall and themselves. Robots are able to pass through lights and foods. Each robot contains four sensors, two for light sensors and two for food sensors. Each sensor has different connection types and impacts on the wheels of the robots so that it creates four different models of the robot: Fear, Aggression, Love, and Explore which are called Braitenberg vehicles. These sensor will affect the motion behavior of the robot by the position of the stimulus in the arena. When the game starts, robots will express Fear and Explore to the arena. After 30 seconds, the robot will get hungry and start to search for foods. The robot consumes food when it gets within 5 pixels of food entity. If a robot has not consumed any food for 120 seconds, it will become very hungry and start to ignore all lights in the arena. At this stage, the robot only focuses on food. If the robot could not consume any food within 150 seconds, it is considered starving and the game will end. At this stage, the user has to start the new game. In order to run this program, user must locate the executable file named arenaviewer in the build directory. The user then run the following command: ./arenaviewer in the command prompt. The interface enables the user to configure the simulation. There are different sliders for the number of robots, lights, and foods in the arena. Additionally, there is an option to turn on/off food in case the user only wants to test the behavior of robots with lights. There is a slider to control the sensitivity of robot's sensors with respect to the distance with the stimulus. After configuring the area, the user clicks new game to start the simulation. The user can only configure at the beginning of the simulation or when the simulation ends except that the users are still able to adjust the sensitivity of sensors. If no food option was selected, robots will not ever get hungry. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
